{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nimport * as React from 'react';\nimport { Component, useEffect } from 'react';\nimport { clsx } from 'clsx';\nimport { Layer } from '../container/Layer';\nimport { Dot } from '../shape/Dot';\nimport { Label } from '../component/Label';\nimport { isNumOrStr } from '../util/DataUtils';\nimport { createLabeledScales } from '../util/CartesianUtils';\nimport { filterProps } from '../util/ReactUtils';\nimport { addDot, removeDot } from '../state/referenceElementsSlice';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectAxisScale } from '../state/selectors/axisSelectors';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { useClipPathId } from '../container/ClipPathProvider';\nvar useCoordinate = (x, y, xAxisId, yAxisId, ifOverflow) => {\n  var isX = isNumOrStr(x);\n  var isY = isNumOrStr(y);\n  var isPanorama = useIsPanorama();\n  var xAxisScale = useAppSelector(state => selectAxisScale(state, 'xAxis', xAxisId, isPanorama));\n  var yAxisScale = useAppSelector(state => selectAxisScale(state, 'yAxis', yAxisId, isPanorama));\n  if (!isX || !isY || xAxisScale == null || yAxisScale == null) {\n    return null;\n  }\n  var scales = createLabeledScales({\n    x: xAxisScale,\n    y: yAxisScale\n  });\n  var result = scales.apply({\n    x,\n    y\n  }, {\n    bandAware: true\n  });\n  if (ifOverflow === 'discard' && !scales.isInRange(result)) {\n    return null;\n  }\n  return result;\n};\nfunction ReportReferenceDot(props) {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(addDot(props));\n    return () => {\n      dispatch(removeDot(props));\n    };\n  });\n  return null;\n}\nvar renderDot = (option, props) => {\n  var dot;\n  if (/*#__PURE__*/React.isValidElement(option)) {\n    dot = /*#__PURE__*/React.cloneElement(option, props);\n  } else if (typeof option === 'function') {\n    dot = option(props);\n  } else {\n    dot = /*#__PURE__*/React.createElement(Dot, _extends({}, props, {\n      cx: props.cx,\n      cy: props.cy,\n      className: \"recharts-reference-dot-dot\"\n    }));\n  }\n  return dot;\n};\nfunction ReferenceDotImpl(props) {\n  var {\n    x,\n    y,\n    r\n  } = props;\n  var clipPathId = useClipPathId();\n  var coordinate = useCoordinate(x, y, props.xAxisId, props.yAxisId, props.ifOverflow);\n  if (!coordinate) {\n    return null;\n  }\n  var {\n    x: cx,\n    y: cy\n  } = coordinate;\n  var {\n    shape,\n    className,\n    ifOverflow\n  } = props;\n  var clipPath = ifOverflow === 'hidden' ? \"url(#\".concat(clipPathId, \")\") : undefined;\n  var dotProps = _objectSpread(_objectSpread({\n    clipPath\n  }, filterProps(props, true)), {}, {\n    cx,\n    cy\n  });\n  return /*#__PURE__*/React.createElement(Layer, {\n    className: clsx('recharts-reference-dot', className)\n  }, renderDot(shape, dotProps), Label.renderCallByParent(props, {\n    x: cx - r,\n    y: cy - r,\n    width: 2 * r,\n    height: 2 * r\n  }));\n}\nfunction ReferenceDotSettingsDispatcher(props) {\n  var {\n    x,\n    y,\n    r,\n    ifOverflow,\n    yAxisId,\n    xAxisId\n  } = props;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ReportReferenceDot, {\n    y: y,\n    x: x,\n    r: r,\n    yAxisId: yAxisId,\n    xAxisId: xAxisId,\n    ifOverflow: ifOverflow\n  }), /*#__PURE__*/React.createElement(ReferenceDotImpl, props));\n}\n\n// eslint-disable-next-line react/prefer-stateless-function\nexport class ReferenceDot extends Component {\n  render() {\n    return /*#__PURE__*/React.createElement(ReferenceDotSettingsDispatcher, this.props);\n  }\n}\n_defineProperty(ReferenceDot, \"displayName\", 'ReferenceDot');\n_defineProperty(ReferenceDot, \"defaultProps\", {\n  ifOverflow: 'discard',\n  xAxisId: 0,\n  yAxisId: 0,\n  r: 10,\n  fill: '#fff',\n  stroke: '#ccc',\n  fillOpacity: 1,\n  strokeWidth: 1\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}